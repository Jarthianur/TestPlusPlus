<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: simple-cpp-test-framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">simple-cpp-test-framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/Jarthianur/simple-cpp-test-framework"></a> <a href="https://travis-ci.org/Jarthianur/simple-cpp-test-framework"></a> <a href="https://travis-ci.org/Jarthianur/simple-cpp-test-framework"></a> <a href="https://travis-ci.org/Jarthianur/simple-cpp-test-framework"></a> <a href="https://codecov.io/gh/Jarthianur/simple-cpp-test-framework"></a> <a href="https://bettercodehub.com/"></a></p>
<p><b>This is a simple header-only testing framework for C++11/14/17 featuring a simple, yet powerfull API, and the capability to parallelize tests, using <em>OpenMP</em>.</b></p>
<p>To use it, just include the all in one <a href="https://github.com/Jarthianur/simple-cpp-test-framework/releases/download/1.2/sctf.hpp">header</a> into your builds.</p>
<p><em>So why actually writing a new testing framework?</em></p>
<p>There are great C++ testing frameworks available out there, but each has its pro's and con's. When I started to write proper tests for my projects, I couldn't find a testing framework that completely suited my needs. So I thought, why not just writing my own, which simply has every feature I'd like. As a side effect this project was - and is still - a great opportunity to improve my C++ skills. This framework is designed around simplicity and effectiveness, for the user as well as the frameworks code itself. There is no excessive documentation reading required, or complicated build integration. Everything is hidden that distracts you from focusing on what really counts, writing qualitative tests. Of course this framework might not suite all <em>your</em> needs, hence feel free to provide suggestions, or request a feature you'd wish. Please have a look at the full <a href="#feature-set">feature set</a>.</p>
<h2>Contents</h2>
<ul>
<li><a href="#simple-cpp-test-framework">simple-cpp-test-framework</a><ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#feature-set">Feature Set</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#test-styles">Test Styles</a></li>
<li><a href="#scopes-and-fixtures">Scopes and Fixtures</a></li>
<li><a href="#floating-point-numbers">Floating Point Numbers</a></li>
<li><a href="#regular-expressions">Regular Expressions</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#simple-unit-test">Simple Unit Test</a></li>
<li><a href="#behavior-driven-test">Behavior Driven Test</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#tests">Tests</a></li>
<li><a href="#reporters">Reporters</a></li>
<li><a href="#comparators">Comparators</a></li>
<li><a href="#assertions">Assertions</a></li>
</ul>
</li>
<li><a href="#parallelization-of-tests">Parallelization Of Tests</a></li>
<li><a href="#how-to-extend">How To Extend</a><ul>
<li><a href="#reporters-1">Reporters</a></li>
<li><a href="#comparators-1">Comparators</a></li>
<li><a href="#value-stringification">Value Stringification</a></li>
</ul>
</li>
<li><a href="#contributing">Contributing</a></li>
</ul>
</li>
</ul>
<h2>Feature Set</h2>
<p>As a short summary of all features, have a look at this list.</p>
<ul>
<li>Single header file for inclusion</li>
<li>Self registering test suites</li>
<li>Comparator based assertions<ul>
<li>equals</li>
<li>unequals</li>
<li>less than</li>
<li>greater than</li>
<li>in range (substring, contains)</li>
<li>regex match, search</li>
</ul>
</li>
<li>Report generation in different formats<ul>
<li>JUnit XML</li>
<li>markdown</li>
<li>console output</li>
</ul>
</li>
<li><b>Multithreaded test execution with OpenMP</b></li>
<li><b>Output capturing per testcase (even when multithreaded)</b></li>
<li>Unit and behavior-driven test styles</li>
<li>Compatible compilers<ul>
<li>gcc</li>
<li>clang</li>
<li>msvc</li>
</ul>
</li>
</ul>
<h2>Usage</h2>
<p>Just inlude the <em>sctf.hpp</em> header file into your build. Tests can then be written in source files and simply linked into your test binary. If you prefer, you can of course write tests in header files and include them in your main source file. <em>Note that it is not possible to write multiple testsuites, or tests in one line, as it would break name generation.</em> To run and report all tests, just create a reporter and call its <code>report()</code> function in your <code>main()</code>, as seen in the examples. Alternatively invoke the <code>SCTF_DEFAULT_MAIN(...)</code> macro in one of your source files and pass it a call to any reporter factory method. In order to run tests in multiple threads you have to enable OpenMP at compilation (e.g. for gcc add <code>-fopenmp</code> flag). Every output to stdout, or stderr from inside tests is captured per testcase, and can be included in the report.</p>
<h3>Test Styles</h3>
<p>Basically two approaches of writing tests exist. One is the classic unit test style, where tests are generally designed around an implementation. The other is behavior driven test style (BDD), where tests are designed around the behavior of an implementation. No matter which of them you prefer, this framework serves both. Actually both styles require just a little different syntax. In the end <code>DESCRIBE</code> is just an other macro for <code>SUITE</code>, same with <code>IT</code> and <code>TEST</code>. If you'd wish to name them differently, just define your own wrapper macro for them with whatever name you like.</p>
<h3>Scopes and Fixtures</h3>
<p>A testsuite is nothing else than a class definition under the hood, which is instantiated with static lifetime. Hence the same scoping rules as for usual class definitions apply to testsuites. Testcases are member functions of their testsuite. Hence the usual scoping rules for methods apply to them.</p>
<p>You might know the need for fixtures, basically an instance of a unit under test (UUT), in other contexts. It is up to you to decide whether testcases should be isolated, or run against a designated fixture. This framework supports the usage of fixtures, as you can just declare any object at testsuite scope - remember, it's just a member field in the end. Also it is possible to define functions that will be executed once before and after all testcases, and before and after each testcase. But be carefull when you use these features in multithreaded tests, as there is no additional synchronization happening. Have a look at the examples, or the <a href="#api">API</a> to see how this is done exactly.</p>
<p>The use of a testsuite wide UUT instance might also be usefull, if it is expensive to construct and initiate.</p>
<h3>Floating Point Numbers</h3>
<p>As floating-point comparison relies on a so called epsilon, we use the machine epsilon by default. But this may lead into false-negative test results, as it could be too accurate. In order to use a custom epsilon, there are two ways to achieve this. First, you can provide a macro in each compilation unit, which is called <code>SCTF_EPSILON</code> with a satisfying value like <code>0.000001</code>. A compiler invocation could look like <code>g++ -std=c++11 test.cpp -DSCTF_EPSILON=0.000001</code>. Or you provide it before including <em>sctf.hpp</em> like in the example below. The second way, is to provide it as an extern variable. Therefor define <code>SCTF_EXTERN_EPSILON</code> before including <em>sctf.hpp</em> and afterwards invoke the <code>SCTF_SET_EPSILON(...)</code> macro with a satisfying value in your main source file.</p>
<h3>Regular Expressions</h3>
<p>This framework provides two comparators for regular expression matching, <code>MATCH</code> and <code>LIKE</code>. The first one does a full match, while the second does a search. When passing a cstring, or string to these comparators a default <code>std::regex</code> is used. To provide better support there are literal operators <code>"you regex"_re</code>, and <code>"your regex"_re_i</code> for case insensitive matching. Both operators create regular expressions with <em>ECMAScript</em> syntax.</p>
<h3>Examples</h3>
<h4>Simple Unit Test</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#define SCTF_EXTERN_EPSILON</span></div><div class="line"><span class="preprocessor">#include &quot;sctf.hpp&quot;</span></div><div class="line">SCTF_SET_EPSILON(0.001)</div><div class="line">SCTF_DEFAULT_MAIN(create_xml_reporter())</div><div class="line"></div><div class="line">SUITE(&quot;testSomething&quot;) {</div><div class="line">    TEST(<span class="stringliteral">&quot;abc&quot;</span>) {</div><div class="line">        ASSERT(x+1, EQ, 11);</div><div class="line">        ASSERT(<span class="stringliteral">&quot;hello world&quot;</span>, MATCH, <span class="stringliteral">&quot;.*&quot;</span>_re);</div><div class="line">        ASSERT(<span class="stringliteral">&quot;xyz&quot;</span>s, !IN, <span class="stringliteral">&quot;hello&quot;</span>s);</div><div class="line">        <span class="keywordtype">int</span> i = 101;</div><div class="line">        ASSERT_NOT_NULL(&amp;i);</div><div class="line">    }</div><div class="line">    TEST(<span class="stringliteral">&quot;multiple numbers&quot;</span>) {</div><div class="line">        ASSERT_EQUALS(0, 0);</div><div class="line">        ASSERT_ZERO(0.0);</div><div class="line">        ASSERT_TRUE(<span class="keyword">true</span>);</div><div class="line">        ASSERT_NOT(.0, EQUALS, 1.0);</div><div class="line">        ASSERT(6, IN_RANGE, std::pair&lt;int, int&gt;(1, 5));</div><div class="line">    }</div><div class="line">    TEST(<span class="stringliteral">&quot;ranges&quot;</span>) {</div><div class="line">        ASSERT(<span class="charliteral">&#39;w&#39;</span>, IN, std::string(<span class="stringliteral">&quot;world&quot;</span>));</div><div class="line">        ASSERT(std::string(<span class="stringliteral">&quot;&quot;</span>), IN, std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;&quot;</span>});</div><div class="line">    }</div><div class="line">    TEST(<span class="stringliteral">&quot;exceptions&quot;</span>) {</div><div class="line">        ASSERT_THROWS(<span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;&quot;</span>), std::logic_error);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h4>Behavior Driven Test</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#define SCTF_EPSILON 0.00001</span></div><div class="line"><span class="preprocessor">#include &quot;sctf.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">    <span class="keywordflow">return</span> sctf::create_markdown_reporter(<span class="stringliteral">&quot;results.md&quot;</span>)-&gt;report();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class </span>MyClass {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keywordtype">int</span> i = 0;</div><div class="line">        <span class="keywordtype">bool</span> <span class="keyword">function</span>() { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div><div class="line">};</div><div class="line"></div><div class="line">DESCRIBE(<span class="stringliteral">&quot;testMyClass&quot;</span>) {</div><div class="line">    MyClass my;</div><div class="line"></div><div class="line">    SETUP() {</div><div class="line">        my.i = 1;</div><div class="line">    }</div><div class="line">    AFTER_EACH() {</div><div class="line">        my.i++;</div><div class="line">    }</div><div class="line"></div><div class="line">    IT(<span class="stringliteral">&quot;should return true&quot;</span>) {</div><div class="line">        ASSERT_TRUE(my.function());</div><div class="line">    }</div><div class="line">    IT(<span class="stringliteral">&quot;should hold i larger than 0&quot;</span>) {</div><div class="line">        ASSERT(my.i, GT, 0);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><h2>API</h2>
<h3>Tests</h3>
<table class="doxtable">
<tr>
<th>Macro </th><th>Arguments </th><th>Description  </th></tr>
<tr>
<td>SUITE, DESCRIBE </td><td>description </td><td>Create a testsuite. </td></tr>
<tr>
<td>SUITE_PAR, DESCRIBE_PAR </td><td>description </td><td>Create a testsuite, where all tests will get executed concurrently in multiple threads. </td></tr>
<tr>
<td>TEST, IT </td><td>description </td><td>Create a testcase in a testsuite. </td></tr>
<tr>
<td>SETUP </td><td></td><td>Define a function, which will be executed once before all testcases. Thrown exceptions will get ignored. </td></tr>
<tr>
<td>TEARDOWN </td><td></td><td>Define a function, which will be executed once after all testcases. Thrown exceptions will get ignored. </td></tr>
<tr>
<td>BEFORE_EACH </td><td></td><td>Define a function, which will be executed before each testcase. Thrown exceptions will get ignored. </td></tr>
<tr>
<td>AFTER_EACH </td><td></td><td>Define a function, which will be executed after each testcase. Thrown exceptions will get ignored. </td></tr>
</table>
<h3>Reporters</h3>
<table class="doxtable">
<tr>
<th>Format </th><th>Factory Method </th><th>Arguments (default)  </th></tr>
<tr>
<td>Console oriented plain text </td><td>create_console_reporter </td><td>output stream/file (stdout), ANSI colors (false), captured output (false) </td></tr>
<tr>
<td>JUnit XML </td><td>create_xml_reporter </td><td>output stream/file (stdout), captured output (false) </td></tr>
<tr>
<td>Markdown </td><td>create_markdown_reporter </td><td>output stream/file (stdout), captured output (false) </td></tr>
</table>
<h3>Comparators</h3>
<p><b>Note:</b> Assertions are based on comparators. Every comparator provides a negation operator <code>!</code>, which allows the logical negation of the actual comparison. For example <code>ASSERT(1, !EQ, 1)</code> and <code>ASSERT(1, NE, 1)</code> are logically equivalent.</p>
<table class="doxtable">
<tr>
<th>Comparator </th><th>Description  </th></tr>
<tr>
<td>EQUALS, EQ </td><td>Compare two values to be equal. </td></tr>
<tr>
<td>UNEQUALS, NE </td><td>Compare two values to be not equal. </td></tr>
<tr>
<td>GREATER_THAN, GREATER, GT </td><td>Compare one value to be greater than another. </td></tr>
<tr>
<td>LESS_THAN, LESS, LT </td><td>Compare one value to be less than another. </td></tr>
<tr>
<td>IN_RANGE, IN </td><td>Check a value to be in range of any container. This means for containers (C++ "ranges") to contain the value and for strings to contain a substring. </td></tr>
<tr>
<td>MATCH </td><td>Match a given string to a regular expression. </td></tr>
<tr>
<td>LIKE </td><td>Search a regular expression in a given string. </td></tr>
</table>
<h3>Assertions</h3>
<table class="doxtable">
<tr>
<th>Assertion </th><th>Parameters </th><th>Description  </th></tr>
<tr>
<td>ASSERT </td><td>VALUE, COMP, EXPECT </td><td>Assert successfull comparison of VALUE and EXPECT with COMP. </td></tr>
<tr>
<td>ASSERT_NOT </td><td>VALUE, COMP, EXPECT </td><td>Assert with negated comparison. Equivalent to <code>!COMP</code>. </td></tr>
<tr>
<td>ASSERT_EQ </td><td>VALUE, EXPECT </td><td>Assert using <em>EQUALS</em> comparator. </td></tr>
<tr>
<td>ASSERT_TRUE </td><td>VALUE </td><td>Assert VALUE to be <em>true</em>. </td></tr>
<tr>
<td>ASSERT_FALSE </td><td>VALUE </td><td>Assert VALUE to be <em>false</em>. </td></tr>
<tr>
<td>ASSERT_NOT_NULL </td><td>VALUE </td><td>Assert VALUE to be not <em>nullptr</em>. </td></tr>
<tr>
<td>ASSERT_NULL </td><td>VALUE </td><td>Assert VALUE to be <em>nullptr</em>. </td></tr>
<tr>
<td>ASSERT_ZERO </td><td>VALUE </td><td>Assert VALUE to be <em>0</em>. </td></tr>
<tr>
<td>ASSERT_THROWS </td><td>STMT, TYPE </td><td>Assert STMT to throw an exception of TYPE. Multiple statements can be split by <code>;</code>. </td></tr>
<tr>
<td>ASSERT_NOTHROW </td><td>STMT </td><td>Assert STMT not to throw any exception. Multiple statements can be split by <code>;</code>. </td></tr>
<tr>
<td>ASSERT_RUNTIME </td><td>STMT, MILLIS </td><td>Assert STMT to run in MILLIS milliseconds at maximum. The statement is not interrupted, if the time exceeds MILLIS. Multiple statements can be split by <code>;</code>. </td></tr>
</table>
<h2>Parallelization Of Tests</h2>
<p>This testing framework serves the capability of parallelizing tests, using OpenMP. Actually it is not really parallel, but concurrent. Nevertheless, it may reduce test durations massively. Keep in mind that tests, running concurrently, <em>must</em> be completely independent from each other. The same rules for usual multithreading apply here, to not produce dataraces, or deadlocks. As long as testcases do not share any data, it is completely threadsafe. If testcases share data, like fixtures, you have to take care of synchronization, meaning that all invokations on your shared data needs to be threadsafe. This also applies to <code>BEFORE_EACH</code> and <code>AFTER_EACH</code> definitions, while <code>SETUP</code> and <code>TEARDOWN</code> are executed synchronous. You may also use parallel tests to test a components threadsafety - actually not a proper way of testing threadsafety. Also consider, spawning threads has some overhead. Thus there is no point in running just a few, anyway fast tests concurrently. <em>Usually</em> the threadpool is kept alive in the background. So if you use parallel testsuites once, don't be afraid to use them wherever you can, even for short tests, as there is not much more overhead.</p>
<h2>How To Extend</h2>
<h3>Reporters</h3>
<p>To add a new reporter just implement the <a href="include/reporter/reporter.hpp">reporter</a> interface. Have a look at the preimplemented reporters, how this is exactly done.</p>
<h3>Comparators</h3>
<p>To add a new comparator you basically just need to invoke two macros. For example:</p>
<div class="fragment"><div class="line">COMPARATOR(pred, <span class="stringliteral">&quot;predecessor of&quot;</span>, value + 1 == expect)</div><div class="line">PROVIDE_COMPARATOR(pred, PRE)</div></div><!-- fragment --><p>This will create a generic comparator for you. The syntax is as follows: <code>COMPARATOR(NAME, CONSTRAINT, PREDICATE)</code>, where <em>NAME</em> is the comparator name. <em>CONSTRAINT</em> is a cstring representing what it does and is used for reporting. <em>PREDICATE</em> is the actual comparison. If you need some more complex comparators, have a look at the <a href="include/comparator/inrange.hpp">in_range</a> to see how it is implemented.</p>
<h3>Value Stringification</h3>
<p>To allow proper reporting, every asserted value/type needs to be stringified somehow. This framework uses an approach to convert every value to string if possible, else the typename is used. If you need to handle custom types in a certain way, just specialize the <a href="include/common/stringify.hpp">to_string</a> template.</p>
<h2>Contributing</h2>
<p>Contribution to this project is always welcome. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
